-- ex2
alter table detailscommandes
add CONSTRAINT fk_truc FOREIGN KEY (produitId) REFERENCES produits(produitId);

-- ex 3
Select DISTINCT nom, type 
from (
    SELECT c.nom ,'client' as type
    from clients c
    UNION
    
    select t.nom , 'transporteur' as type
    from transporteurs t
    UNION 

	SELECT f.nom , 'fournisseur' as type
	from fournisseurs f
)As type
order by type ASC

-- ex4
-- Donnez, en utilisant un opérateur ensembliste, la requête SQL qui permet d’obtenir la liste, triée par nom, des clients qui n'ont jamais commandé : nom, ville et pays du client

SELECT nom , ville , Pays
from clients
WHERE clientId not in (
    SELECT c.clientId
    from commandes c
    )
order by nom asc;

-- ex5
-- Donnez deux requêtes SQL qui permettent d’obtenir la liste des clients qui sont aussi des fournisseurs (même nom, même nom de contact) : nom, nom du contact, adresse, ville, pays

(SELECT c.nom , c.nomContact , c.adresse, c.ville , c.Pays
from clients c)
INTERSECT
(SELECT nom , nomContact , adresse, ville , Pays
    from fournisseurs
    )
-- zx6


-- ex7
select e.nom, e.prenom
from employes e where not EXISTS(
	select *
    from commandes co
    join clients c on co.clientId = c.clientId
    WHERE co.responsableId = e.employeId
    and c.Pays = 'France');


select e.nom , e.prenom
from employes e 
where e.employeId not in(
    select co.responsableId
    from commandes co inner join clients c on co.clientId = c.clientId
    WHERE co.responsableId = e.employeId
    and c.Pays = 'France'
   );
   
   
SELECT nom,prenom
FROM employes
except(Select e2.nom,e2.prenom
       from employes e2 inner join commandes co on co.responsableId = e2.employeId
       inner join clients c on co.clientId = c.clientId
       WHERE c.Pays = 'France');
       
       
       
Select e.nom , e.prenom
from (commandes co inner join clients c on co.clientId = c.clientId and c.Pays ='France')
RIGHT join employes e on co.responsablesId = e.employeId
where co.commandeId is NULL;

-- onnez la requête SQL qui permet d’obtenir la liste des produits dont le prix est supérieur à
-- la moyenne de leur catégorie : libelle et prix du produit, libelle de la catégorie, prix moyen de
-- la catégorie (sans CTE)

SELECT avg(p.prix) , p.libelle , c.libelle
from produits p inner join categories c on p.categorieId = c.categorieId
WHERE p.prix > (SELECT avg(pr.prix) from produits pr WHERE p.categorieId = pr.categorieId)


-- ex9
-- Donnez la requête SQL qui permet d’obtenir les 5 clients qui ont généré le plus de chiffre d'affaires ; trié par le total de leurs ventes décroissant : nom du client, nombre de commandes, total de leurs commandes 
-- Remarque : LIMIT n permet de ne conserver que les n premières lignes du résultat de la requête

SELECT c.nom ,count (DISTINCT co.commandeId) as nb, sum(dc.quantite*p.prix) as ca
from clients c
inner join commandes co on c.clientId = co.clientId
inner join detailscommandes dc on co.commandeId = dc.commandeId
inner join produits p on dc.produitId = p.produitId
group by c.clientId, c.nom
order by 3 desc
limit 5;

-- ex 10
select c.nom as 'clients obsolètes' , count(co.commandeId) as nbCommande, DATEDIFF(curdate(),co.dateCommande) as 'nbJours'
from clients c inner join commandes co on c.clientId = co.clientId
where DATEDIFF(curdate(),co.dateCommande) > 730
group by c.nom
order by 3,2,1 asc

-- ex 11 . Donnez la requête SQL qui permet d’obtenir la liste des ventes totales 2025 par mois chaque catégorie : libellé de la catégorie, nom du mois, nom de l’année, montant vendu de la catégorie
-- a) MONTHNAME(unedate) permet d’obtenir le nom du mois d’une date sur MySQL/MariaDB
-- b) YEAR(unedate) permet d’obtenir l’année d’une date sur MySQL/MariaDB

select (d.quantite * p.prix) as oui , p.libelle , MONTHNAME(co.dateCommande) , Year(co.dateCommande) 
from detailscommandes d 
inner join produits p on p.produitId = d.produitId  
inner join commandes co on co.commandeId = d.commandeId
where co.dateCommande between '2025-01-01' and '2025-12-31'
group by  p.libelle 

