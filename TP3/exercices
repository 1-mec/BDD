-- ex2
alter table detailscommandes
add CONSTRAINT fk_truc FOREIGN KEY (produitId) REFERENCES produits(produitId);

-- ex 3
Select DISTINCT nom, type 
from (
    SELECT c.nom ,'client' as type
    from clients c
    UNION
    
    select t.nom , 'transporteur' as type
    from transporteurs t
    UNION 

	SELECT f.nom , 'fournisseur' as type
	from fournisseurs f
)As type
order by type ASC

-- ex4
-- Donnez, en utilisant un opérateur ensembliste, la requête SQL qui permet d’obtenir la liste, triée par nom, des clients qui n'ont jamais commandé : nom, ville et pays du client

SELECT nom , ville , Pays
from clients
WHERE clientId not in (
    SELECT c.clientId
    from commandes c
    )
order by nom asc;

-- ex5
-- Donnez deux requêtes SQL qui permettent d’obtenir la liste des clients qui sont aussi des fournisseurs (même nom, même nom de contact) : nom, nom du contact, adresse, ville, pays

(SELECT c.nom , c.nomContact , c.adresse, c.ville , c.Pays
from clients c)
INTERSECT
(SELECT nom , nomContact , adresse, ville , Pays
    from fournisseurs
    )
-- zx6


-- ex7
select e.nom, e.prenom
from employes e where not EXISTS(
	select *
    from commandes co
    join clients c on co.clientId = c.clientId
    WHERE co.responsableId = e.employeId
    and c.Pays = 'France');


select e.nom , e.prenom
from employes e 
where e.employeId not in(
    select co.responsableId
    from commandes co inner join clients c on co.clientId = c.clientId
    WHERE co.responsableId = e.employeId
    and c.Pays = 'France'
   );
   
   
SELECT nom,prenom
FROM employes
except(Select e2.nom,e2.prenom
       from employes e2 inner join commandes co on co.responsableId = e2.employeId
       inner join clients c on co.clientId = c.clientId
       WHERE c.Pays = 'France');
       
       
       
Select e.nom , e.prenom
from (commandes co inner join clients c on co.clientId = c.clientId and c.Pays ='France')
RIGHT join employes e on co.responsablesId = e.employeId
where co.commandeId is NULL;

-- onnez la requête SQL qui permet d’obtenir la liste des produits dont le prix est supérieur à
-- la moyenne de leur catégorie : libelle et prix du produit, libelle de la catégorie, prix moyen de
-- la catégorie (sans CTE)

SELECT avg(p.prix) , p.libelle , c.libelle
from produits p inner join categories c on p.categorieId = c.categorieId
WHERE p.prix > (SELECT avg(pr.prix) from produits pr WHERE p.categorieId = pr.categorieId)


-- ex9
-- Donnez la requête SQL qui permet d’obtenir les 5 clients qui ont généré le plus de chiffre d'affaires ; trié par le total de leurs ventes décroissant : nom du client, nombre de commandes, total de leurs commandes 
-- Remarque : LIMIT n permet de ne conserver que les n premières lignes du résultat de la requête

SELECT c.nom ,count (DISTINCT co.commandeId) as nb, sum(dc.quantite*p.prix) as ca
from clients c
inner join commandes co on c.clientId = co.clientId
inner join detailscommandes dc on co.commandeId = dc.commandeId
inner join produits p on dc.produitId = p.produitId
group by c.clientId, c.nom
order by 3 desc
limit 5;

-- ex 10
select c.nom as 'clients obsolètes' , count(co.commandeId) as nbCommande, DATEDIFF(curdate(),co.dateCommande) as 'nbJours'
from clients c inner join commandes co on c.clientId = co.clientId
where DATEDIFF(curdate(),co.dateCommande) > 730
group by c.nom
order by 3,2,1 asc

-- ex 11 . Donnez la requête SQL qui permet d’obtenir la liste des ventes totales 2025 par mois chaque catégorie : libellé de la catégorie, nom du mois, nom de l’année, montant vendu de la catégorie
-- a) MONTHNAME(unedate) permet d’obtenir le nom du mois d’une date sur MySQL/MariaDB
-- b) YEAR(unedate) permet d’obtenir l’année d’une date sur MySQL/MariaDB

select (d.quantite * p.prix) as oui , p.libelle , MONTHNAME(co.dateCommande) , Year(co.dateCommande) 
from detailscommandes d 
inner join produits p on p.produitId = d.produitId  
inner join commandes co on co.commandeId = d.commandeId
where co.dateCommande between '2025-01-01' and '2025-12-31'
group by  p.libelle 

11.
SELECT 
    cat.libelle AS 'Catégorie',
    MONTHNAME(co.dateCommande) AS 'Mois', 
    YEAR(co.dateCommande) AS 'Année',
    SUM(dc.quantite * p.prix) AS 'Chiffre d\'affaires'
FROM categories cat 
INNER JOIN produits p ON cat.categorieId = p.categorieId 
INNER JOIN detailsCommandes dc ON p.produitId = dc.produitId
INNER JOIN commandes co ON co.commandeId = dc.commandeId
WHERE YEAR(co.dateCommande) = 2025
GROUP BY cat.libelle, MONTH(co.dateCommande), MONTHNAME(co.dateCommande), YEAR(co.dateCommande)
ORDER BY YEAR(co.dateCommande), MONTH(co.dateCommande), cat.libelle;

12.
SELECT c.nom,DENSE_RANK() OVER(ORDER BY COUNT(*) DESC) AS 'rang' , co.dateCommande
FROM clients c inner join commandes co on co.clientId = c.clientId
GROUP BY c.nom ;


13.
SELECT c.nom, COUNT(*), row_number() OVER(ORDER BY c.nom DESC) AS 'rang' , co.dateCommande
FROM clients c inner join commandes co on co.clientId = c.clientId
GROUP BY c.nom ,co.dateCommande ;


14.
SELECT p.libelle, co.commandeId, co.dateCommande, dc.quantite, SUM(dc.quantite) OVER(PARTITION BY p.produitId ORDER BY co.commandeId)
FROM commandes co INNER JOIN detailsCommandes dc ON dc.commandeId=co.commandeId INNER JOIN produits p ON p.produitId=dc.produitId
ORDER BY p.libelle, co.commandeId

15.
SELECT 
    c.nom,
    c.clientId,
    co.commandeId,
    co.dateCommande,
    -- Commande précédente du même client
    LAG(co.dateCommande) OVER(
        PARTITION BY c.clientId 
        ORDER BY co.dateCommande
    ) AS date_commande_precedente,
    
    -- Commande suivante du même client
    LEAD(co.dateCommande) OVER(
        PARTITION BY c.clientId 
        ORDER BY co.dateCommande
    ) AS date_commande_suivante,
    
    -- Différence avec la commande précédente
    DATEDIFF(
        co.dateCommande,
        LAG(co.dateCommande) OVER(
            PARTITION BY c.clientId 
            ORDER BY co.dateCommande
        )
    ) AS jours_depuis_derniere_commande
    
FROM clients c 
INNER JOIN commandes co ON co.clientId = c.clientId
ORDER BY c.clientId, co.dateCommande;

18.
WITH total_clients AS (
    SELECT 
        c.nom, 
        c.pays, 
        SUM(dc.quantite * p.prix) AS montant_total
    FROM produits p 
    INNER JOIN detailsCommandes dc ON dc.produitId = p.produitId 
    INNER JOIN commandes co ON co.commandeId = dc.commandeId 
    INNER JOIN clients c ON c.clientId = co.clientId
    GROUP BY c.nom, c.pays
)

SELECT 
    nom, 
    pays, 
    montant_total,
    (SELECT AVG(montant_total) FROM total_clients) AS moyenne_totale,
    montant_total - (SELECT AVG(montant_total) FROM total_clients) AS difference
FROM total_clients
WHERE montant_total > (SELECT AVG(montant_total) FROM total_clients)
ORDER BY montant_total DESC;

19. 
WITH les_clients AS (
    SELECT 
        Pays AS pays,
        COUNT(*) AS nombre_clients
    FROM clients
    GROUP BY Pays
),

les_fournisseurs AS (
    SELECT 
        pays,
        COUNT(*) AS nombre_fournisseurs
    FROM fournisseurs  -- IMPORTANT : table fournisseurs !
    GROUP BY pays
),

tous_pays AS (
    SELECT pays FROM les_clients
    UNION
    SELECT pays FROM les_fournisseurs
)

SELECT 
    tp.pays,
    COALESCE(lc.nombre_clients, 0) + COALESCE(lf.nombre_fournisseurs, 0) AS nombre_tiers
FROM tous_pays tp
LEFT JOIN les_clients lc ON tp.pays = lc.pays
LEFT JOIN les_fournisseurs lf ON tp.pays = lf.pays
ORDER BY tp.pays;

-- 20
WITH produits_avec_moyenne AS (
    SELECT 
        p.libelle AS produit,
        p.prix as prix,
        c.libelle AS categorie,
        AVG(p.prix) OVER (PARTITION BY c.categorieId) AS prix_moyen_categorie
    FROM produits p
    INNER JOIN categories c ON p.categorieId = c.categorieId
)
SELECT 
    produit,
    prix,
    categorie,
    prix_moyen_categorie
FROM produits_avec_moyenne
WHERE prix > prix_moyen_categorie
ORDER BY categorie, prix DESC;

-- 21 
--  Donnez la requête SQL qui permet d’obtenir la liste des clients qui ont commandé plus de 5
-- fois sur une durée d’au moins 3 ans : nom du client, nombre de commandes, date de la 1ere
-- commande, date de la dernière commande, durée entre la 1ere et la derbière commande
with cli as (
    SELECT c.nom , COUNT(co.dateCommande) as cnt , MIN(co.dateCommande) le_min , MAX(co.dateCommande) le_max
    from clients c inner join commandes co on c.clientId = co.clientId
    group by c.nom
    having COUNT(co.dateCommande) > 5
)
SELECT nom , cnt ,le_min,le_max, DATEDIFF(le_max, le_min) as la_diff
    from cli
    where DATEDIFF( CURDATE() , le_min) >=  1095


-- 22 
WITH ventes_par_trimestre AS (
    SELECT 
        YEAR(co.dateCommande) AS annee,
        QUARTER(co.dateCommande) AS trimestre,
        COUNT(DISTINCT co.commandeId) AS nb_commandes,
        SUM(dc.quantite * p.prix) AS montant_total
    FROM commandes co
    INNER JOIN detailscommandes dc ON co.commandeId = dc.commandeId
    INNER JOIN produits p ON dc.produitId = p.produitId
    GROUP BY YEAR(co.dateCommande), QUARTER(co.dateCommande)
),

ventes_avec_precedent AS (
    SELECT 
        annee,
        trimestre,
        nb_commandes,
        montant_total,
        LAG(montant_total) OVER (ORDER BY annee, trimestre desc) AS montant_trimestre_precedent,
        LAG(nb_commandes) OVER (ORDER BY annee, trimestre desc) AS nb_commandes_precedent
    FROM ventes_par_trimestre
)

SELECT 
    annee,
    trimestre,
    nb_commandes,
    montant_total AS montant_total_trimestre,
    montant_trimestre_precedent AS montant_trimestre_precedent,
    montant_total - montant_trimestre_precedent AS difference_montant,
    ((montant_total - montant_trimestre_precedent) / montant_trimestre_precedent) * 100 AS evolution_pourcentage,
    nb_commandes - nb_commandes_precedent AS difference_nb_commandes
FROM ventes_avec_precedent
ORDER BY annee, trimestre desc;

-- 23
-- Donnez la requête SQL qui permet d’obtenir une segmentation des clients (les clients avec
-- plus de 10 commandes sont client « Or », avec plus de 5 commandes « Argent », sinon
-- « Bronze ») : segment client (Or, Argent ou Bronze), nombre de clients dans le segment,
-- nombre moyen de commandes, montant moyen commandé par segment client

WITH commandes_par_client AS (
    SELECT 
        c.clientId,
        c.nom,
        COUNT(co.commandeId) AS nb_commandes,
        SUM(dc.quantite * p.prix) AS montant_total
    FROM clients c
    LEFT JOIN commandes co ON c.clientId = co.clientId
    LEFT JOIN detailscommandes dc ON co.commandeId = dc.commandeId
    LEFT JOIN produits p ON dc.produitId = p.produitId
    GROUP BY c.clientId, c.nom
),

segmentation AS (
    SELECT 
        clientId,
        nom,
        nb_commandes,
        montant_total,
        CASE 
            WHEN nb_commandes > 10 THEN 'Or'
            WHEN nb_commandes > 5 THEN 'Argent'
            ELSE 'Bronze'
        END AS segment
    FROM commandes_par_client
)

SELECT 
    segment,
    COUNT(*) AS nombre_clients,
    ROUND(AVG(nb_commandes), 2) AS moyenne_commandes,
    ROUND(AVG(montant_total), 2) AS montant_moyen
FROM segmentation
GROUP BY segment
ORDER BY 
    CASE segment
        WHEN 'Or' THEN 1
        WHEN 'Argent' THEN 2
        WHEN 'Bronze' THEN 3
    END;

